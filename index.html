<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    import React, { useMemo, useState } from 'react'

// Student Finance Manager - Single-file React prototype (TailwindCSS)
// - Default export is a React component that previews a personal finance dashboard
// - Demonstrates: automated categorization, predictive spending analysis, goal tracking, alerts
// - For production: replace local simulation with backend services, bank integrations, and ML models

export default function StudentFinanceManagerPrototype() {
  // --- Sample data ---
  const [transactions, setTransactions] = useState([
    { id: 1, date: '2025-05-02', description: 'Starbucks', amount: 4.5 },
    { id: 2, date: '2025-05-03', description: 'Metro Card', amount: 2.75 },
    { id: 3, date: '2025-05-04', description: 'Textbook — Data Structures', amount: 62 },
    { id: 4, date: '2025-06-01', description: 'Groceries — Whole Foods', amount: 45.2 },
    { id: 5, date: '2025-06-05', description: 'Utilities — Electricity', amount: 30.8 },
    { id: 6, date: '2025-06-10', description: 'Night out — Pizza', amount: 18 },
    { id: 7, date: '2025-07-03', description: 'Gym Membership', amount: 20 },
    { id: 8, date: '2025-07-10', description: 'Online Course Subscription', amount: 12.99 },
    { id: 9, date: '2025-07-14', description: 'Coffee Shop', amount: 3.75 },
  ])

  const [budget, setBudget] = useState(600) // monthly budget
  const [savingsGoal, setSavingsGoal] = useState({ target: 1200, saved: 300, deadline: '2025-12-01' })

  // --- Simple keyword-based categorizer (demo) ---
  function categorizeDescription(desc) {
    const text = desc.toLowerCase()
    if (text.includes('coffee') || text.includes('starbucks') || text.includes('coffee shop')) return 'Coffee & Snacks'
    if (text.includes('grocery') || text.includes('groceries') || text.includes('whole foods')) return 'Groceries'
    if (text.includes('metro') || text.includes('uber') || text.includes('taxi')) return 'Transport'
    if (text.includes('textbook') || text.includes('course') || text.includes('subscription')) return 'Education'
    if (text.includes('gym')) return 'Health & Fitness'
    if (text.includes('utilities') || text.includes('electricity') || text.includes('water')) return 'Bills'
    if (text.includes('pizza') || text.includes('night out')) return 'Dining & Entertainment'
    return 'Other'
  }

  // Add category to transactions lazily
  const categorized = useMemo(() => transactions.map(t => ({ ...t, category: categorizeDescription(t.description) })), [transactions])

  // --- Aggregate monthly totals (YYYY-MM) ---
  function monthKey(dateStr) { return dateStr.slice(0,7) }
  const monthlyTotals = useMemo(() => {
    const map = {}
    categorized.forEach(t => {
      const m = monthKey(t.date)
      map[m] = (map[m] || 0) + t.amount
    })
    // return sorted list of { month, total }
    return Object.keys(map).sort().map(m => ({ month: m, total: Math.round(map[m]*100)/100 }))
  }, [categorized])

  // --- Simple linear regression to predict next N months ---
  function linearPredict(monthly, monthsAhead=3) {
    if (monthly.length === 0) return []
    // x: 0..n-1, y: totals
    const x = monthly.map((_, i) => i)
    const y = monthly.map(m => m.total)
    const n = x.length
    const sumX = x.reduce((a,b)=>a+b,0)
    const sumY = y.reduce((a,b)=>a+b,0)
    const sumXY = x.reduce((s, xi, i) => s + xi*y[i], 0)
    const sumX2 = x.reduce((s, xi) => s + xi*xi, 0)
    const denom = n*sumX2 - sumX*sumX
    const slope = denom === 0 ? 0 : (n*sumXY - sumX*sumY) / denom
    const intercept = (sumY - slope*sumX)/n
    const preds = []
    for (let i = 0; i < monthsAhead; i++) {
      const xi = n + i
      preds.push({ monthIndex: xi, total: Math.round((intercept + slope*xi)*100)/100 })
    }
    return preds
  }

  const predictions = useMemo(() => linearPredict(monthlyTotals, 3), [monthlyTotals])

  // --- Alerts ---
  const alerts = useMemo(() => {
    const lastMonth = monthlyTotals[monthlyTotals.length-1]
    const alertList = []
    if (lastMonth && lastMonth.total > budget) alertList.push({ type: 'budget', message: `Your spending for ${lastMonth.month} was $${lastMonth.total} which is above your budget $${budget}.` })
    // predicted next month
    if (predictions.length > 0 && predictions[0].total > budget) alertList.push({ type: 'forecast', message: `Predicted spending next month: $${predictions[0].total} — consider trimming variable costs.` })
    // goal progress
    const monthsLeft = Math.max(1, Math.ceil((new Date(savingsGoal.deadline) - new Date())/(1000*60*60*24*30)))
    const requiredPerMonth = Math.max(0, (savingsGoal.target - savingsGoal.saved)/monthsLeft)
    if (requiredPerMonth > (budget*0.3)) alertList.push({ type: 'goal', message: `To hit your savings goal of $${savingsGoal.target} by ${savingsGoal.deadline}, you'd need to save ~$${Math.round(requiredPerMonth)}/month.` })
    return alertList
  }, [monthlyTotals, budget, predictions, savingsGoal])

  // --- Small handlers for demo ---
  function addTransaction(t) {
    setTransactions(prev => [...prev, { id: Date.now(), ...t }])
  }

  // --- Small SVG sparkline for monthly totals + predictions ---
  function Sparkline({ data, preds }) {
    const all = [...data.map(d=>d.total), ...preds.map(p=>p.total)]
    if (all.length === 0) return <div className="text-xs text-slate-500">No data</div>
    const w = 300, h = 72, pad = 6
    const min = Math.min(...all, 0)
    const max = Math.max(...all)
    const scaleX = (i) => pad + (i/(all.length-1))*(w-2*pad)
    const scaleY = (v) => h - pad - ((v-min)/(max-min || 1))*(h-2*pad)
    const pointsActual = data.map((d,i)=>`${scaleX(i)},${scaleY(d.total)}`).join(' ')
    const pointsPred = preds.map((p,i)=>`${scaleX(data.length+i)},${scaleY(p.total)}`).join(' ')
    return (
      <svg width={w} height={h} className="block">
        <polyline points={pointsActual} fill="none" stroke="#374151" strokeWidth={2} strokeLinecap="round" strokeLinejoin="round" />
        <polyline points={pointsPred} fill="none" stroke="#6366f1" strokeWidth={2} strokeDasharray="4 4" strokeLinecap="round" strokeLinejoin="round" />
      </svg>
    )
  }

  return (
    <div className="min-h-screen bg-slate-50 text-slate-900">
      <header className="flex items-center justify-between p-4 bg-white shadow">
        <div className="flex items-center gap-3">
          <div className="w-10 h-10 rounded-lg bg-gradient-to-tr from-green-500 to-teal-400 flex items-center justify-center text-white font-bold">SF</div>
          <h1 className="text-xl font-semibold">Student Finance Manager</h1>
          <span className="ml-3 text-sm text-slate-500">Automated categorization • Predictive analytics • Goal tracking</span>
        </div>
        <div className="flex gap-3 items-center">
          <div className="text-sm text-slate-600">Budget: ${budget}/mo</div>
          <button className="px-3 py-1 rounded-md bg-indigo-600 text-white text-sm">Connect Bank</button>
        </div>
      </header>

      <main className="p-6 grid grid-cols-12 gap-6">
        <aside className="col-span-3 bg-white rounded-2xl p-4 shadow-sm">
          <h2 className="font-semibold">Overview</h2>
          <div className="mt-4 grid gap-3">
            <div className="p-3 rounded-md bg-emerald-50">
              <div className="text-xs text-slate-500">Available Balance (demo)</div>
              <div className="text-xl font-semibold">$1,220</div>
            </div>
            <div className="p-3 rounded-md bg-indigo-50">
              <div className="text-xs text-slate-500">Monthly Spending (last)</div>
              <div className="text-lg font-semibold">${monthlyTotals[monthlyTotals.length-1]?.total ?? 0}</div>
            </div>
            <div className="p-3 rounded-md bg-yellow-50">
              <div className="text-xs text-slate-500">Savings Goal</div>
              <div className="text-lg font-semibold">${savingsGoal.saved}/${savingsGoal.target}</div>
              <div className="text-xs text-slate-500">By {savingsGoal.deadline}</div>
            </div>
          </div>

          <div className="mt-6">
            <h3 className="text-sm font-medium">Quick Actions</h3>
            <div className="mt-3 flex flex-col gap-2">
              <button className="py-1 rounded-md bg-slate-100">Add manual transaction</button>
              <button className="py-1 rounded-md bg-slate-100">Set Monthly Budget</button>
              <button className="py-1 rounded-md bg-slate-100">Adjust Savings Goal</button>
            </div>
          </div>
        </aside>

        <section className="col-span-6 bg-white rounded-2xl p-4 shadow-sm flex flex-col">
          <div className="flex items-center justify-between">
            <h2 className="font-semibold">Spending & Predictions</h2>
            <div className="text-sm text-slate-500">Projection based on past months (demo)</div>
          </div>

          <div className="mt-4">
            <Sparkline data={monthlyTotals} preds={predictions} />
            <div className="mt-3 grid grid-cols-3 gap-3">
              {monthlyTotals.slice(-3).map(m => (
                <div key={m.month} className="p-3 rounded-md bg-slate-50">
                  <div className="text-xs text-slate-500">{m.month}</div>
                  <div className="font-semibold">${m.total}</div>
                </div>
              ))}

              {predictions.map((p, i) => (
                <div key={i} className="p-3 rounded-md bg-indigo-50">
                  <div className="text-xs text-slate-500">Predicted</div>
                  <div className="font-semibold">${p.total}</div>
                </div>
              ))}
            </div>

            <div className="mt-4">
              <h3 className="text-sm font-medium">Category breakdown (last 90 days)</h3>
              <div className="mt-2 text-sm text-slate-600">{[...new Set(categorized.map(c=>c.category))].map(cat => {
                const total = categorized.filter(t=>t.category===cat).reduce((s,t)=>s+t.amount,0)
                return `${cat}: $${Math.round(total*100)/100}`
              }).join(' • ')}</div>
            </div>

          </div>
        </section>

        <aside className="col-span-3 bg-white rounded-2xl p-4 shadow-sm">
          <h2 className="font-semibold">Alerts & Tips</h2>
          <div className="mt-3 space-y-2">
            {alerts.length === 0 && <div className="text-sm text-slate-500">No alerts — your plan looks healthy!</div>}
            {alerts.map((a,i) => (
              <div key={i} className="p-2 rounded-md bg-red-50 text-sm text-red-700">{a.message}</div>
            ))}
          </div>

          <div className="mt-6">
            <h3 className="text-sm font-medium">Goal Tracker</h3>
            <div className="mt-2">
              <div className="text-sm">Goal: ${savingsGoal.target}</div>
              <div className="text-sm">Saved: ${savingsGoal.saved}</div>
              <div className="mt-2 w-full h-3 bg-slate-100 rounded-full overflow-hidden">
                <div style={{ width: `${Math.min(100, (savingsGoal.saved/savingsGoal.target)*100)}%` }} className="h-full bg-emerald-400" />
              </div>
            </div>
          </div>
        </aside>

        {/* Transactions table */}
        <section className="col-span-12 bg-white rounded-2xl p-4 shadow-sm">
          <div className="flex items-center justify-between">
            <h2 className="font-semibold">Transactions</h2>
            <div className="text-sm text-slate-500">Automated categorization (keyword demo)</div>
          </div>

          <div className="mt-3 overflow-x-auto">
            <table className="w-full text-sm">
              <thead className="text-slate-500 text-xs text-left">
                <tr>
                  <th className="py-2">Date</th>
                  <th>Description</th>
                  <th>Category</th>
                  <th className="text-right">Amount</th>
                </tr>
              </thead>
              <tbody>
                {categorized.map(tx => (
                  <tr key={tx.id} className="border-t">
                    <td className="py-2">{tx.date}</td>
                    <td>{tx.description}</td>
                    <td className="text-xs text-slate-600">{tx.category}</td>
                    <td className="text-right">${tx.amount}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </section>

      </main>

      <footer className="p-4 text-center text-xs text-slate-500">Prototype · For production, integrate bank APIs (Plaid/OpenID equiv), use ML pipeline for categorization and forecasting, and secure user data with encryption.</footer>
    </div>
  )
}

/*

--- Platform Design Notes (for product & engineering) ---

1) Core features
  - Automated expense categorization (ML model + rules fallback)
  - Predictive spending analysis (time-series forecasting, anomaly detection)
  - Goal tracking & recommendations (what to save monthly to hit target)
  - Budget alerts and proactive nudges (SMS/push/email when at risk)
  - Secure bank integrations (Plaid, SaltEdge, or open banking APIs)
  - User-friendly dashboard with actionable insights and drilldowns

2) Suggested architecture
  - Frontend: React + Tailwind (Monaco optional for some features), WebSockets for realtime alerts
  - Backend: Python (FastAPI) or Node.js (Express) for orchestration
  - Bank connectors: Plaid or regional open-banking; tokenized accounts
  - Data storage: PostgreSQL for transactions, Redis for caching, S3 for backups and exports
  - ML & analytics: Feature store, time-series DB (e.g., InfluxDB or simply Postgres), and model serving via TorchServe or FastAPI endpoints
  - Execution & infra: Kubernetes cluster or serverless functions for scaled workloads

3) ML pipeline
  - Categorization: fine-tune a small classifier on transaction descriptions + merchant metadata; backstop with rule-based heuristics
  - Forecasting: use Prophet or a light LSTM/Temporal Fusion Transformer for student-specific patterns; start with linear or exponential smoothing for MVP
  - Anomaly detection: seasonal decomposition + z-score checks and model-based residual checks

4) APIs (examples)
  - POST /api/transactions/sync -> triggers bank sync, returns jobId
  - GET /api/transactions?from=&to=&category= -> returns transactions
  - POST /api/categorize -> { transactions: [...] } -> categorized
  - POST /api/forecast -> { historical: [...] } -> { predictions: [...] }
  - POST /api/alerts/register -> create push/sms/email alerts

5) Data model (high-level)
  - User { id, name, email, timezone, preferences }
  - Account { id, userId, provider, lastSync, maskedAccount }
  - Transaction { id, accountId, date, amount, description, merchant, category, raw }
  - Goal { id, userId, target, saved, deadline, type }
  - Alert { id, userId, type, threshold, channel }

6) Security & privacy
  - Tokenized bank credentials (never store raw credentials)
  - Encrypt sensitive fields at rest (transactions metadata) and in transit (TLS)
  - Role-based access control for multi-user family/guardian accounts
  - GDPR/CCPA support for data deletion/export

7) Compliance
  - Follow regional open-banking rules for bank connectors
  - PCI DSS considerations if handling payment instruments (avoid storing card numbers)

8) MVP roadmap
  - Week 0-4: Prototype frontend (this), backend skeleton, simulated data flow
  - Week 4-8: Bank connector integration, rule-based categorizer, simple forecasting (linear/Prophet)
  - Week 8-12: ML categorizer training pipeline, alerts engine, user settings
  - Week 12+: Polishing UI, mobile push notifications, cohort-based personalization, A/B testing

9) UX notes
  - Onboarding: link accounts, categorize sample transactions, set goals
  - Privacy-first defaults: private by default, explicit sharing toggles
  - Explainability: show why a transaction was categorized; allow users to correct and retrain

--- End of design notes ---
*/

</body>
</html>